<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<xsl:output method="xml" indent="no" omit-xml-declaration="yes" />
	<xsl:template match="/">
--DDC information for database: <xsl:value-of select="//documentation/@database" />
--This script inserts documention as extended properties into another instance of the database.
--Generated by <xsl:value-of select="//documentation/@generator" /> version <xsl:value-of select="//documentation/@generator_version" />.
--Generated on <xsl:value-of select="//documentation/@date" />
--Generated using SQL Server 2005 syntax

USE [<xsl:value-of select="//documentation/@database" />]
GO

if not object_id('ExtendedProperty_Set') is null
	drop procedure dbo.ExtendedProperty_Set;
GO

create procedure dbo.ExtendedProperty_Set
(
	@fieldName sysname
	, @value nvarchar(4000)
	, @tableName sysname
	, @columnType sysname = null
	, @columnName sysname = null
	, @tableSchema sysname = 'dbo'
)
AS
if exists ( select 1 from sys.fn_listextendedproperty (
	@fieldName,
	'schema', @tableSchema,
	'table', @tableName,
	@columnType, @columnName ) )
begin
	EXEC sp_dropextendedproperty
		@name = @fieldName
		,@level0type = 'schema'
		,@level0name = @tableSchema
		,@level1type = 'table'
		,@level1name = @tableName
		,@level2type = @columnType
		,@level2name = @columnName;
end

EXEC sp_addextendedproperty
	@name = @fieldName
	,@value = @value
	,@level0type = 'schema'
	,@level0name = @tableSchema
	,@level1type = 'table'
	,@level1name = @tableName
	,@level2type = @columnType
	,@level2name = @columnName;
GO

		<xsl:apply-templates select="documentation/tables/table" />
		<xsl:apply-templates select="documentation/tables/table/column" />

if not object_id('ExtendedProperty_Set') is null
	drop procedure ExtendedProperty_Set
GO

	</xsl:template>

	<xsl:template match="table">
EXEC dbo.ExtendedProperty_Set 
	@fieldName=N'MS_Description', 
	@value=N'<xsl:call-template name="replace-string">
    <xsl:with-param name="text" select="@description"/>
    <xsl:with-param name="from">'</xsl:with-param>
    <xsl:with-param name="to">''</xsl:with-param>
  </xsl:call-template>', 
	@tableName=N'<xsl:value-of select="@name" />', 
	@columnType=null, 
	@columnName=null, 
	@tableSchema=N'<xsl:value-of select="@schema" />';
	</xsl:template>

	<xsl:template match="column">
EXEC dbo.ExtendedProperty_Set 
	@fieldName=N'MS_Description', 
	@value=N'<xsl:call-template name="replace-string">
    <xsl:with-param name="text" select="@description"/>
    <xsl:with-param name="from">'</xsl:with-param>
    <xsl:with-param name="to">''</xsl:with-param>
  </xsl:call-template>', 
	@tableName=N'<xsl:value-of select="../@name"/>', 
	@columnType='column', 
	@columnName=N'<xsl:value-of select="@name" />', 
	@tableSchema=N'<xsl:value-of select="../@schema" />';
  <xsl:for-each select="property">
    EXEC dbo.ExtendedProperty_Set
    @fieldName=N'<xsl:value-of select="@name" />',
    @value=N'<xsl:call-template name="replace-string">
      <xsl:with-param name="text" select="@value"/>
      <xsl:with-param name="from">'</xsl:with-param>
      <xsl:with-param name="to">''</xsl:with-param>
    </xsl:call-template>',
    @tableName=N'<xsl:value-of select="../../@name"/>',
    @columnType='column',
    @columnName=N'<xsl:value-of select="../@name" />',
    @tableSchema=N'<xsl:value-of select="../../@schema" />';
				</xsl:for-each>
	</xsl:template>

  <!-- reusable replace-string function -->
  <xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>
    <xsl:choose>
      <xsl:when test="contains($text, $from)">
        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>
        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
